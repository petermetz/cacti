import type { Express } from "express";
import { Observable } from "rxjs";
import type { Server as SocketIoServer } from "socket.io";
import { Optional } from "typescript-optional";
import { Contract } from "web3-eth-contract";
import { ConsensusAlgorithmFamily, IPluginLedgerConnector, IWebServiceEndpoint, IPluginWebService, ICactusPlugin, ICactusPluginOptions, IPluginGrpcService, IGrpcSvcDefAndImplPair } from "@hyperledger/cactus-core-api";
import { PluginRegistry } from "@hyperledger/cactus-core";
import { LogLevelDesc } from "@hyperledger/cactus-common";
import { GetBalanceV1Request, GetBalanceV1Response, DeployContractSolidityBytecodeNoKeychainV1Request } from "./generated/openapi/typescript-axios/index";
import { GetPastLogsV1Request, GetPastLogsV1Response } from "./generated/openapi/typescript-axios/index";
import { DeployContractSolidityBytecodeV1Request, DeployContractSolidityBytecodeV1Response, InvokeContractV1Request, InvokeContractV1Response, RunTransactionRequest, RunTransactionResponse, SignTransactionRequest, SignTransactionResponse, GetTransactionV1Request, GetTransactionV1Response, GetBlockV1Request, GetBlockV1Response, GetBesuRecordV1Request, GetBesuRecordV1Response } from "./generated/openapi/typescript-axios";
import { PrometheusExporter } from "./prometheus-exporter/prometheus-exporter";
export interface IRunTransactionV1Exchange {
    request: InvokeContractV1Request;
    response: RunTransactionResponse;
    timestamp: Date;
}
export declare const E_KEYCHAIN_NOT_FOUND = "cactus.connector.besu.keychain_not_found";
export interface IPluginLedgerConnectorBesuOptions extends ICactusPluginOptions {
    networkId?: number;
    rpcApiHttpHost: string;
    rpcApiWsHost: string;
    pluginRegistry: PluginRegistry;
    prometheusExporter?: PrometheusExporter;
    viemWebSocketTransportConfig?: Record<string, unknown>;
    logLevel?: LogLevelDesc;
}
export declare class PluginLedgerConnectorBesu implements IPluginLedgerConnector<DeployContractSolidityBytecodeV1Request, DeployContractSolidityBytecodeV1Response, RunTransactionRequest, RunTransactionResponse>, ICactusPlugin, IPluginGrpcService, IPluginWebService {
    readonly options: IPluginLedgerConnectorBesuOptions;
    private readonly instanceId;
    prometheusExporter: PrometheusExporter;
    private readonly log;
    private readonly logLevel;
    private readonly web3Provider;
    private readonly web3;
    private readonly viemClient;
    private readonly viemTransport;
    private readonly viemWebSocketTransportConfig;
    private web3Quorum;
    private readonly pluginRegistry;
    private contracts;
    private endpoints;
    private txSubject;
    static readonly CLASS_NAME = "PluginLedgerConnectorBesu";
    get className(): string;
    constructor(options: IPluginLedgerConnectorBesuOptions);
    getOpenApiSpec(): unknown;
    getPrometheusExporter(): PrometheusExporter;
    getPrometheusExporterMetrics(): Promise<string>;
    getInstanceId(): string;
    getTxSubjectObservable(): Observable<IRunTransactionV1Exchange>;
    onPluginInit(): Promise<void>;
    shutdown(): Promise<void>;
    registerWebServices(app: Express, wsApi: SocketIoServer): Promise<IWebServiceEndpoint[]>;
    createGrpcSvcDefAndImplPairs(): Promise<IGrpcSvcDefAndImplPair[]>;
    createGrpcStreamsSvcDefAndImplPair(): Promise<IGrpcSvcDefAndImplPair>;
    /**
     * Create a new instance of the service implementation.
     * Note: This does not cache the returned objects internally. A new instance
     * is created during every invocation.
     *
     * @returns The gRPC service definition+implementation pair that is backed
     * by the code generated by the OpenAPI generator from the openapi.json spec
     * of this package. Used by the API server to obtain the service objects dynamically
     * at runtime so that the plugin's gRPC services can be exposed in a similar
     * fashion how the HTTP REST endpoints are registered as well.
     */
    createGrpcOpenApiSvcDefAndImplPair(): Promise<IGrpcSvcDefAndImplPair>;
    getOrCreateWebServices(): Promise<IWebServiceEndpoint[]>;
    getPackageName(): string;
    getConsensusAlgorithmFamily(): Promise<ConsensusAlgorithmFamily>;
    hasTransactionFinality(): Promise<boolean>;
    /**
     * Verifies that it is safe to call a specific method of a Web3 Contract.
     *
     * @param contract The Web3 Contract instance to check whether it has a method with a specific name or not.
     * @param name The name of the method that will be checked if it's usable on `contract` or not.
     * @returns Boolean `true` when it IS safe to call the method named `name` on the contract.
     * @throws If the contract instance is falsy or it's methods object is falsy. Also throws if the method name is a blank string.
     */
    isSafeToCallContractMethod(contract: Contract, name: string): Promise<boolean>;
    invokeContract(req: InvokeContractV1Request): Promise<InvokeContractV1Response>;
    transact(req: RunTransactionRequest): Promise<RunTransactionResponse>;
    deployContract(req: DeployContractSolidityBytecodeV1Request): Promise<DeployContractSolidityBytecodeV1Response>;
    deployContractNoKeychain(req: DeployContractSolidityBytecodeNoKeychainV1Request): Promise<DeployContractSolidityBytecodeV1Response>;
    signTransaction(req: SignTransactionRequest): Promise<Optional<SignTransactionResponse>>;
    getBalance(request: GetBalanceV1Request): Promise<GetBalanceV1Response>;
    getTransaction(request: GetTransactionV1Request): Promise<GetTransactionV1Response>;
    getPastLogs(request: GetPastLogsV1Request): Promise<GetPastLogsV1Response>;
    getBlock(request: GetBlockV1Request): Promise<GetBlockV1Response>;
    getBesuRecord(request: GetBesuRecordV1Request): Promise<GetBesuRecordV1Response>;
}
