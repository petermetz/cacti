// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v4.25.1
// source: ccip/offchainreporting2_monitoring_offchain_config.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "monitoring_pb";

export interface OffchainConfigProto {
  deltaProgressNanoseconds: bigint;
  deltaResendNanoseconds: bigint;
  deltaRoundNanoseconds: bigint;
  deltaGraceNanoseconds: bigint;
  deltaStageNanoseconds: bigint;
  rMax: number;
  s: number[];
  offchainPublicKeys: Uint8Array[];
  peerIds: string[];
  reportingPluginConfig: Uint8Array;
  maxDurationQueryNanoseconds: bigint;
  maxDurationObservationNanoseconds: bigint;
  maxDurationReportNanoseconds: bigint;
  maxDurationShouldAcceptFinalizedReportNanoseconds: bigint;
  maxDurationShouldTransmitAcceptedReportNanoseconds: bigint;
  sharedSecretEncryptions:
    | SharedSecretEncryptionsProto
    | undefined;
  /**
   * TODO(petermetz): Figure out the story behind this field which is not
   * in the .proto file in the chainlink-common repo for some reason but the
   * go types in the main chainlink node repo have this field declared anyway.
   * Use `optional` to match the `*uint64` in Go
   */
  maxDurationInitializationNanoseconds?: bigint | undefined;
}

export interface SharedSecretEncryptionsProto {
  diffieHellmanPoint: Uint8Array;
  sharedSecretHash: Uint8Array;
  encryptions: Uint8Array[];
}

function createBaseOffchainConfigProto(): OffchainConfigProto {
  return {
    deltaProgressNanoseconds: 0n,
    deltaResendNanoseconds: 0n,
    deltaRoundNanoseconds: 0n,
    deltaGraceNanoseconds: 0n,
    deltaStageNanoseconds: 0n,
    rMax: 0,
    s: [],
    offchainPublicKeys: [],
    peerIds: [],
    reportingPluginConfig: new Uint8Array(0),
    maxDurationQueryNanoseconds: 0n,
    maxDurationObservationNanoseconds: 0n,
    maxDurationReportNanoseconds: 0n,
    maxDurationShouldAcceptFinalizedReportNanoseconds: 0n,
    maxDurationShouldTransmitAcceptedReportNanoseconds: 0n,
    sharedSecretEncryptions: undefined,
    maxDurationInitializationNanoseconds: undefined,
  };
}

export const OffchainConfigProto: MessageFns<OffchainConfigProto> = {
  encode(message: OffchainConfigProto, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deltaProgressNanoseconds !== 0n) {
      if (BigInt.asUintN(64, message.deltaProgressNanoseconds) !== message.deltaProgressNanoseconds) {
        throw new globalThis.Error(
          "value provided for field message.deltaProgressNanoseconds of type uint64 too large",
        );
      }
      writer.uint32(8).uint64(message.deltaProgressNanoseconds);
    }
    if (message.deltaResendNanoseconds !== 0n) {
      if (BigInt.asUintN(64, message.deltaResendNanoseconds) !== message.deltaResendNanoseconds) {
        throw new globalThis.Error("value provided for field message.deltaResendNanoseconds of type uint64 too large");
      }
      writer.uint32(16).uint64(message.deltaResendNanoseconds);
    }
    if (message.deltaRoundNanoseconds !== 0n) {
      if (BigInt.asUintN(64, message.deltaRoundNanoseconds) !== message.deltaRoundNanoseconds) {
        throw new globalThis.Error("value provided for field message.deltaRoundNanoseconds of type uint64 too large");
      }
      writer.uint32(24).uint64(message.deltaRoundNanoseconds);
    }
    if (message.deltaGraceNanoseconds !== 0n) {
      if (BigInt.asUintN(64, message.deltaGraceNanoseconds) !== message.deltaGraceNanoseconds) {
        throw new globalThis.Error("value provided for field message.deltaGraceNanoseconds of type uint64 too large");
      }
      writer.uint32(32).uint64(message.deltaGraceNanoseconds);
    }
    if (message.deltaStageNanoseconds !== 0n) {
      if (BigInt.asUintN(64, message.deltaStageNanoseconds) !== message.deltaStageNanoseconds) {
        throw new globalThis.Error("value provided for field message.deltaStageNanoseconds of type uint64 too large");
      }
      writer.uint32(40).uint64(message.deltaStageNanoseconds);
    }
    if (message.rMax !== 0) {
      writer.uint32(48).uint32(message.rMax);
    }
    writer.uint32(58).fork();
    for (const v of message.s) {
      writer.uint32(v);
    }
    writer.join();
    for (const v of message.offchainPublicKeys) {
      writer.uint32(66).bytes(v!);
    }
    for (const v of message.peerIds) {
      writer.uint32(74).string(v!);
    }
    if (message.reportingPluginConfig.length !== 0) {
      writer.uint32(82).bytes(message.reportingPluginConfig);
    }
    if (message.maxDurationQueryNanoseconds !== 0n) {
      if (BigInt.asUintN(64, message.maxDurationQueryNanoseconds) !== message.maxDurationQueryNanoseconds) {
        throw new globalThis.Error(
          "value provided for field message.maxDurationQueryNanoseconds of type uint64 too large",
        );
      }
      writer.uint32(88).uint64(message.maxDurationQueryNanoseconds);
    }
    if (message.maxDurationObservationNanoseconds !== 0n) {
      if (BigInt.asUintN(64, message.maxDurationObservationNanoseconds) !== message.maxDurationObservationNanoseconds) {
        throw new globalThis.Error(
          "value provided for field message.maxDurationObservationNanoseconds of type uint64 too large",
        );
      }
      writer.uint32(96).uint64(message.maxDurationObservationNanoseconds);
    }
    if (message.maxDurationReportNanoseconds !== 0n) {
      if (BigInt.asUintN(64, message.maxDurationReportNanoseconds) !== message.maxDurationReportNanoseconds) {
        throw new globalThis.Error(
          "value provided for field message.maxDurationReportNanoseconds of type uint64 too large",
        );
      }
      writer.uint32(104).uint64(message.maxDurationReportNanoseconds);
    }
    if (message.maxDurationShouldAcceptFinalizedReportNanoseconds !== 0n) {
      if (
        BigInt.asUintN(64, message.maxDurationShouldAcceptFinalizedReportNanoseconds) !==
          message.maxDurationShouldAcceptFinalizedReportNanoseconds
      ) {
        throw new globalThis.Error(
          "value provided for field message.maxDurationShouldAcceptFinalizedReportNanoseconds of type uint64 too large",
        );
      }
      writer.uint32(112).uint64(message.maxDurationShouldAcceptFinalizedReportNanoseconds);
    }
    if (message.maxDurationShouldTransmitAcceptedReportNanoseconds !== 0n) {
      if (
        BigInt.asUintN(64, message.maxDurationShouldTransmitAcceptedReportNanoseconds) !==
          message.maxDurationShouldTransmitAcceptedReportNanoseconds
      ) {
        throw new globalThis.Error(
          "value provided for field message.maxDurationShouldTransmitAcceptedReportNanoseconds of type uint64 too large",
        );
      }
      writer.uint32(120).uint64(message.maxDurationShouldTransmitAcceptedReportNanoseconds);
    }
    if (message.sharedSecretEncryptions !== undefined) {
      SharedSecretEncryptionsProto.encode(message.sharedSecretEncryptions, writer.uint32(130).fork()).join();
    }
    if (message.maxDurationInitializationNanoseconds !== undefined) {
      if (
        BigInt.asUintN(64, message.maxDurationInitializationNanoseconds) !==
          message.maxDurationInitializationNanoseconds
      ) {
        throw new globalThis.Error(
          "value provided for field message.maxDurationInitializationNanoseconds of type uint64 too large",
        );
      }
      writer.uint32(136).uint64(message.maxDurationInitializationNanoseconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OffchainConfigProto {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOffchainConfigProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.deltaProgressNanoseconds = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.deltaResendNanoseconds = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.deltaRoundNanoseconds = reader.uint64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.deltaGraceNanoseconds = reader.uint64() as bigint;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.deltaStageNanoseconds = reader.uint64() as bigint;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.rMax = reader.uint32();
          continue;
        }
        case 7: {
          if (tag === 56) {
            message.s.push(reader.uint32());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.s.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.offchainPublicKeys.push(reader.bytes());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.peerIds.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.reportingPluginConfig = reader.bytes();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.maxDurationQueryNanoseconds = reader.uint64() as bigint;
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.maxDurationObservationNanoseconds = reader.uint64() as bigint;
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.maxDurationReportNanoseconds = reader.uint64() as bigint;
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.maxDurationShouldAcceptFinalizedReportNanoseconds = reader.uint64() as bigint;
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.maxDurationShouldTransmitAcceptedReportNanoseconds = reader.uint64() as bigint;
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.sharedSecretEncryptions = SharedSecretEncryptionsProto.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.maxDurationInitializationNanoseconds = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OffchainConfigProto {
    return {
      deltaProgressNanoseconds: isSet(object.deltaProgressNanoseconds) ? BigInt(object.deltaProgressNanoseconds) : 0n,
      deltaResendNanoseconds: isSet(object.deltaResendNanoseconds) ? BigInt(object.deltaResendNanoseconds) : 0n,
      deltaRoundNanoseconds: isSet(object.deltaRoundNanoseconds) ? BigInt(object.deltaRoundNanoseconds) : 0n,
      deltaGraceNanoseconds: isSet(object.deltaGraceNanoseconds) ? BigInt(object.deltaGraceNanoseconds) : 0n,
      deltaStageNanoseconds: isSet(object.deltaStageNanoseconds) ? BigInt(object.deltaStageNanoseconds) : 0n,
      rMax: isSet(object.rMax) ? globalThis.Number(object.rMax) : 0,
      s: globalThis.Array.isArray(object?.s) ? object.s.map((e: any) => globalThis.Number(e)) : [],
      offchainPublicKeys: globalThis.Array.isArray(object?.offchainPublicKeys)
        ? object.offchainPublicKeys.map((e: any) => bytesFromBase64(e))
        : [],
      peerIds: globalThis.Array.isArray(object?.peerIds) ? object.peerIds.map((e: any) => globalThis.String(e)) : [],
      reportingPluginConfig: isSet(object.reportingPluginConfig)
        ? bytesFromBase64(object.reportingPluginConfig)
        : new Uint8Array(0),
      maxDurationQueryNanoseconds: isSet(object.maxDurationQueryNanoseconds)
        ? BigInt(object.maxDurationQueryNanoseconds)
        : 0n,
      maxDurationObservationNanoseconds: isSet(object.maxDurationObservationNanoseconds)
        ? BigInt(object.maxDurationObservationNanoseconds)
        : 0n,
      maxDurationReportNanoseconds: isSet(object.maxDurationReportNanoseconds)
        ? BigInt(object.maxDurationReportNanoseconds)
        : 0n,
      maxDurationShouldAcceptFinalizedReportNanoseconds: isSet(object.maxDurationShouldAcceptFinalizedReportNanoseconds)
        ? BigInt(object.maxDurationShouldAcceptFinalizedReportNanoseconds)
        : 0n,
      maxDurationShouldTransmitAcceptedReportNanoseconds:
        isSet(object.maxDurationShouldTransmitAcceptedReportNanoseconds)
          ? BigInt(object.maxDurationShouldTransmitAcceptedReportNanoseconds)
          : 0n,
      sharedSecretEncryptions: isSet(object.sharedSecretEncryptions)
        ? SharedSecretEncryptionsProto.fromJSON(object.sharedSecretEncryptions)
        : undefined,
      maxDurationInitializationNanoseconds: isSet(object.maxDurationInitializationNanoseconds)
        ? BigInt(object.maxDurationInitializationNanoseconds)
        : undefined,
    };
  },

  toJSON(message: OffchainConfigProto): unknown {
    const obj: any = {};
    if (message.deltaProgressNanoseconds !== 0n) {
      obj.deltaProgressNanoseconds = message.deltaProgressNanoseconds.toString();
    }
    if (message.deltaResendNanoseconds !== 0n) {
      obj.deltaResendNanoseconds = message.deltaResendNanoseconds.toString();
    }
    if (message.deltaRoundNanoseconds !== 0n) {
      obj.deltaRoundNanoseconds = message.deltaRoundNanoseconds.toString();
    }
    if (message.deltaGraceNanoseconds !== 0n) {
      obj.deltaGraceNanoseconds = message.deltaGraceNanoseconds.toString();
    }
    if (message.deltaStageNanoseconds !== 0n) {
      obj.deltaStageNanoseconds = message.deltaStageNanoseconds.toString();
    }
    if (message.rMax !== 0) {
      obj.rMax = Math.round(message.rMax);
    }
    if (message.s?.length) {
      obj.s = message.s.map((e) => Math.round(e));
    }
    if (message.offchainPublicKeys?.length) {
      obj.offchainPublicKeys = message.offchainPublicKeys.map((e) => base64FromBytes(e));
    }
    if (message.peerIds?.length) {
      obj.peerIds = message.peerIds;
    }
    if (message.reportingPluginConfig.length !== 0) {
      obj.reportingPluginConfig = base64FromBytes(message.reportingPluginConfig);
    }
    if (message.maxDurationQueryNanoseconds !== 0n) {
      obj.maxDurationQueryNanoseconds = message.maxDurationQueryNanoseconds.toString();
    }
    if (message.maxDurationObservationNanoseconds !== 0n) {
      obj.maxDurationObservationNanoseconds = message.maxDurationObservationNanoseconds.toString();
    }
    if (message.maxDurationReportNanoseconds !== 0n) {
      obj.maxDurationReportNanoseconds = message.maxDurationReportNanoseconds.toString();
    }
    if (message.maxDurationShouldAcceptFinalizedReportNanoseconds !== 0n) {
      obj.maxDurationShouldAcceptFinalizedReportNanoseconds = message.maxDurationShouldAcceptFinalizedReportNanoseconds
        .toString();
    }
    if (message.maxDurationShouldTransmitAcceptedReportNanoseconds !== 0n) {
      obj.maxDurationShouldTransmitAcceptedReportNanoseconds = message
        .maxDurationShouldTransmitAcceptedReportNanoseconds.toString();
    }
    if (message.sharedSecretEncryptions !== undefined) {
      obj.sharedSecretEncryptions = SharedSecretEncryptionsProto.toJSON(message.sharedSecretEncryptions);
    }
    if (message.maxDurationInitializationNanoseconds !== undefined) {
      obj.maxDurationInitializationNanoseconds = message.maxDurationInitializationNanoseconds.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OffchainConfigProto>, I>>(base?: I): OffchainConfigProto {
    return OffchainConfigProto.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OffchainConfigProto>, I>>(object: I): OffchainConfigProto {
    const message = createBaseOffchainConfigProto();
    message.deltaProgressNanoseconds = object.deltaProgressNanoseconds ?? 0n;
    message.deltaResendNanoseconds = object.deltaResendNanoseconds ?? 0n;
    message.deltaRoundNanoseconds = object.deltaRoundNanoseconds ?? 0n;
    message.deltaGraceNanoseconds = object.deltaGraceNanoseconds ?? 0n;
    message.deltaStageNanoseconds = object.deltaStageNanoseconds ?? 0n;
    message.rMax = object.rMax ?? 0;
    message.s = object.s?.map((e) => e) || [];
    message.offchainPublicKeys = object.offchainPublicKeys?.map((e) => e) || [];
    message.peerIds = object.peerIds?.map((e) => e) || [];
    message.reportingPluginConfig = object.reportingPluginConfig ?? new Uint8Array(0);
    message.maxDurationQueryNanoseconds = object.maxDurationQueryNanoseconds ?? 0n;
    message.maxDurationObservationNanoseconds = object.maxDurationObservationNanoseconds ?? 0n;
    message.maxDurationReportNanoseconds = object.maxDurationReportNanoseconds ?? 0n;
    message.maxDurationShouldAcceptFinalizedReportNanoseconds =
      object.maxDurationShouldAcceptFinalizedReportNanoseconds ?? 0n;
    message.maxDurationShouldTransmitAcceptedReportNanoseconds =
      object.maxDurationShouldTransmitAcceptedReportNanoseconds ?? 0n;
    message.sharedSecretEncryptions =
      (object.sharedSecretEncryptions !== undefined && object.sharedSecretEncryptions !== null)
        ? SharedSecretEncryptionsProto.fromPartial(object.sharedSecretEncryptions)
        : undefined;
    message.maxDurationInitializationNanoseconds = object.maxDurationInitializationNanoseconds ?? undefined;
    return message;
  },
};

function createBaseSharedSecretEncryptionsProto(): SharedSecretEncryptionsProto {
  return { diffieHellmanPoint: new Uint8Array(0), sharedSecretHash: new Uint8Array(0), encryptions: [] };
}

export const SharedSecretEncryptionsProto: MessageFns<SharedSecretEncryptionsProto> = {
  encode(message: SharedSecretEncryptionsProto, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.diffieHellmanPoint.length !== 0) {
      writer.uint32(10).bytes(message.diffieHellmanPoint);
    }
    if (message.sharedSecretHash.length !== 0) {
      writer.uint32(18).bytes(message.sharedSecretHash);
    }
    for (const v of message.encryptions) {
      writer.uint32(26).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SharedSecretEncryptionsProto {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSharedSecretEncryptionsProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.diffieHellmanPoint = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sharedSecretHash = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.encryptions.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SharedSecretEncryptionsProto {
    return {
      diffieHellmanPoint: isSet(object.diffieHellmanPoint)
        ? bytesFromBase64(object.diffieHellmanPoint)
        : new Uint8Array(0),
      sharedSecretHash: isSet(object.sharedSecretHash) ? bytesFromBase64(object.sharedSecretHash) : new Uint8Array(0),
      encryptions: globalThis.Array.isArray(object?.encryptions)
        ? object.encryptions.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: SharedSecretEncryptionsProto): unknown {
    const obj: any = {};
    if (message.diffieHellmanPoint.length !== 0) {
      obj.diffieHellmanPoint = base64FromBytes(message.diffieHellmanPoint);
    }
    if (message.sharedSecretHash.length !== 0) {
      obj.sharedSecretHash = base64FromBytes(message.sharedSecretHash);
    }
    if (message.encryptions?.length) {
      obj.encryptions = message.encryptions.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SharedSecretEncryptionsProto>, I>>(base?: I): SharedSecretEncryptionsProto {
    return SharedSecretEncryptionsProto.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SharedSecretEncryptionsProto>, I>>(object: I): SharedSecretEncryptionsProto {
    const message = createBaseSharedSecretEncryptionsProto();
    message.diffieHellmanPoint = object.diffieHellmanPoint ?? new Uint8Array(0);
    message.sharedSecretHash = object.sharedSecretHash ?? new Uint8Array(0);
    message.encryptions = object.encryptions?.map((e) => e) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
